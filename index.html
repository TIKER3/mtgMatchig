<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MTG 複合フォーマット マッチングツール</title>
    <style>
        body { font-family: "Helvetica Neue", Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background-color: #f4f4f4; color: #333; }
        h1, h2 { text-align: center; color: #2c3e50; }
        .container { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        
        /* Setup Phase */
        .player-input { margin-bottom: 10px; display: flex; gap: 10px; flex-wrap: wrap; }
        .player-input input { padding: 8px; flex: 1; border: 1px solid #ddd; border-radius: 4px; }
        
        /* Button Styles */
        button { background-color: #e67e22; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-size: 16px; width: 100%; margin-top: 10px; }
        button:hover { background-color: #d35400; }
        button:disabled { background-color: #ccc; cursor: not-allowed; }

        /* Match Styles */
        .match-card { background: #ecf0f1; border-left: 5px solid #3498db; padding: 10px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        .match-info { font-weight: bold; }
        .vs { margin: 0 10px; color: #7f8c8d; font-size: 0.9em; }
        .result-btns { display: flex; gap: 5px; }
        .result-btns button { width: auto; font-size: 12px; padding: 5px 10px; margin: 0; }
        .p1-win { background-color: #3498db; }
        .p2-win { background-color: #e74c3c; }
        .draw { background-color: #95a5a6; }
        
        /* Table Styles */
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: center; }
        th { background-color: #2c3e50; color: white; }
        tr:nth-child(even) { background-color: #f9f9f9; }

        .hidden { display: none; }
        .format-badge { display: inline-block; padding: 5px 10px; background: #8e44ad; color: white; border-radius: 15px; font-size: 0.9em; margin-bottom: 15px; }
        .pod-label { font-size: 0.8em; color: white; padding: 2px 6px; border-radius: 4px; margin-left: 5px; }
        .pod-a { background-color: #2980b9; }
        .pod-b { background-color: #c0392b; }
    </style>
</head>
<body>

<div class="container" id="setupSection">
    <h1>トーナメント参加登録</h1>
    <p>参加者16名の名前を入力してください。</p>
    <div id="playerInputs"></div>
    <button onclick="startTournament()">トーナメント開始</button>
</div>

<div class="container hidden" id="tournamentSection">
    <h2 id="roundTitle">Round 1</h2>
    <div style="text-align: center;">
        <span id="currentFormat" class="format-badge">Draft</span>
    </div>
    
    <div id="pairingsList"></div>
    <button id="nextRoundBtn" onclick="nextRound()" disabled>全結果を入力してください</button>

    <div style="margin-top: 30px;">
        <h3>現在の順位表</h3>
        <table id="standingsTable">
            <thead>
                <tr>
                    <th>順位</th>
                    <th>名前</th>
                    <th>点</th>
                    <th>OMW%</th>
                    <th>Pod</th>
                </tr>
            </thead>
            <tbody></tbody>
        </table>
    </div>
</div>

<script>
    // --- Configuration ---
    const TOTAL_PLAYERS = 16;
    const ROUND_STRUCTURE = [
        { num: 1, format: "Draft (Pod内対戦)" },
        { num: 2, format: "Draft (Pod内対戦)" },
        { num: 3, format: "Draft (Pod内対戦)" },
        { num: 4, format: "Standard" },
        { num: 5, format: "Standard" },
        { num: 6, format: "Pioneer" },
        { num: 7, format: "Pioneer" },
        { num: 8, format: "Modern" },
        { num: 9, format: "Modern" }
    ];

    // --- State ---
    let players = [];
    let currentRoundIndex = 0;
    let matches = []; // { p1: id, p2: id, result: null|1|2|0 } 1=p1win, 2=p2win, 0=draw

    // --- Initialization ---
    window.onload = function() {
        const inputContainer = document.getElementById('playerInputs');
        for (let i = 0; i < TOTAL_PLAYERS; i++) {
            const div = document.createElement('div');
            div.className = 'player-input';
            div.innerHTML = `<input type="text" id="p${i}" value="Player ${i+1}" placeholder="Player Name">`;
            inputContainer.appendChild(div);
        }
    };

    class Player {
        constructor(id, name) {
            this.id = id;
            this.name = name;
            this.points = 0;
            this.opponents = []; // List of IDs played against
            this.pod = ''; // 'A' or 'B'
            this.wins = 0;
            this.losses = 0;
            this.draws = 0;
        }
    }

    function startTournament() {
        // Create Players
        for (let i = 0; i < TOTAL_PLAYERS; i++) {
            const name = document.getElementById(`p${i}`).value || `Player ${i+1}`;
            const p = new Player(i, name);
            // Randomly assign pods (First 8 A, Next 8 B) - In reality, usually based on seating, but here we split simple
            // To make it truly random shuffle could be added, but here input order 1-8=A, 9-16=B
            p.pod = i < 8 ? 'A' : 'B';
            players.push(p);
        }

        document.getElementById('setupSection').classList.add('hidden');
        document.getElementById('tournamentSection').classList.remove('hidden');
        
        generatePairings();
        updateUI();
    }

    function generatePairings() {
        matches = [];
        const isDraft = currentRoundIndex < 3;
        
        // Sort players by points for pairing logic
        // Simple Swiss logic: Sort by Points -> Random
        // NOTE: Does not implement complex OMW% pairing lookahead, keeps it simple for browser JS
        
        let pool = [...players];

        // Shuffle within same point groups to randomize pairs slightly
        pool.sort(() => Math.random() - 0.5);
        pool.sort((a, b) => b.points - a.points);

        if (isDraft) {
            // Split into Pods
            const podA = pool.filter(p => p.pod === 'A');
            const podB = pool.filter(p => p.pod === 'B');
            
            pairSwissGroup(podA);
            pairSwissGroup(podB);
        } else {
            // Global Swiss
            pairSwissGroup(pool);
        }
    }

    function pairSwissGroup(group) {
        // specific simple pairing logic
        // Try to pair p1 with p2 if not played. If played, try p3...
        // Fallback: Pair neighbors in sorted list even if played (rematch) to prevent infinite loops in simple script
        
        let unpaired = [...group];
        
        while (unpaired.length > 1) {
            let p1 = unpaired.shift();
            let p2Index = -1;

            // Find first valid opponent
            for (let i = 0; i < unpaired.length; i++) {
                if (!p1.opponents.includes(unpaired[i].id)) {
                    p2Index = i;
                    break;
                }
            }

            // If everyone played, just take the top one (Rematch fallback)
            if (p2Index === -1) {
                p2Index = 0;
            }

            let p2 = unpaired.splice(p2Index, 1)[0];
            matches.push({ p1: p1.id, p2: p2.id, result: null });
        }
        
        if (unpaired.length === 1) {
            // Bye (Not possible with 16 players unless drop, handling just in case)
            // console.log("Bye for", unpaired[0].name);
            // Auto win for bye could be added here
        }
    }

    function updateUI() {
        const roundData = ROUND_STRUCTURE[currentRoundIndex];
        document.getElementById('roundTitle').innerText = `Round ${roundData.num}`;
        document.getElementById('currentFormat').innerText = roundData.format;
        
        const list = document.getElementById('pairingsList');
        list.innerHTML = '';

        matches.forEach((m, idx) => {
            const p1 = players.find(p => p.id === m.p1);
            const p2 = players.find(p => p.id === m.p2);
            
            const div = document.createElement('div');
            div.className = 'match-card';
            
            let status = '';
            if (m.result === 1) status = ` - ${p1.name} Win`;
            else if (m.result === 2) status = ` - ${p2.name} Win`;
            else if (m.result === 0) status = ` - Draw`;

            // Pod badge for draft rounds
            let podBadge = '';
            if (currentRoundIndex < 3) {
                podBadge = `<span class="pod-label ${p1.pod === 'A' ? 'pod-a' : 'pod-b'}">Pod ${p1.pod}</span>`;
            }

            div.innerHTML = `
                <div class="match-info">
                    ${podBadge} Table ${idx+1}: ${p1.name} <span class="vs">vs</span> ${p2.name}
                    <span style="font-weight:normal; color:#666;">${status}</span>
                </div>
                <div class="result-btns">
                    <button class="p1-win" onclick="setResult(${idx}, 1)">${p1.name} Win</button>
                    <button class="p2-win" onclick="setResult(${idx}, 2)">${p2.name} Win</button>
                    <button class="draw" onclick="setResult(${idx}, 0)">Draw</button>
                </div>
            `;
            list.appendChild(div);
        });

        checkRoundComplete();
        updateStandings();
    }

    function setResult(matchIdx, result) {
        matches[matchIdx].result = result;
        updateUI();
    }

    function checkRoundComplete() {
        const allDone = matches.every(m => m.result !== null);
        const btn = document.getElementById('nextRoundBtn');
        btn.disabled = !allDone;
        if (allDone) {
            btn.innerText = (currentRoundIndex < ROUND_STRUCTURE.length - 1) ? "次のラウンドへ" : "大会終了 - 最終結果";
        } else {
            btn.innerText = "全結果を入力してください";
        }
    }

    function nextRound() {
        if (!confirm("ラウンドを終了して次へ進みますか？（修正できなくなります）")) return;

        // Commit scores
        matches.forEach(m => {
            const p1 = players.find(p => p.id === m.p1);
            const p2 = players.find(p => p.id === m.p2);
            
            // Record opponent
            p1.opponents.push(p2.id);
            p2.opponents.push(p1.id);

            if (m.result === 1) { // P1 Win
                p1.points += 3; p1.wins++;
                p2.losses++;
            } else if (m.result === 2) { // P2 Win
                p2.points += 3; p2.wins++;
                p1.losses++;
            } else { // Draw
                p1.points += 1; p1.draws++;
                p2.points += 1; p2.draws++;
            }
        });

        currentRoundIndex++;
        
        if (currentRoundIndex >= ROUND_STRUCTURE.length) {
            alert("全ラウンド終了！お疲れ様でした。");
            document.getElementById('pairingsList').innerHTML = '<div style="text-align:center; padding:20px;">全日程終了</div>';
            document.getElementById('nextRoundBtn').style.display = 'none';
            document.getElementById('currentFormat').style.display = 'none';
            updateStandings();
            return;
        }

        generatePairings();
        updateUI();
    }

    function updateStandings() {
        // Calculate basic OMW% (Average of Opponents' Win %)
        // Win% = Points / (Rounds * 3). Minimum 0.33 usually used in official logic but simplistic here.
        
        const tbody = document.querySelector('#standingsTable tbody');
        tbody.innerHTML = '';

        // Recalculate OMW for display sorting
        players.forEach(p => {
            if (p.opponents.length === 0) {
                p.omw = 0;
                return;
            }
            let totalOpWinPct = 0;
            p.opponents.forEach(opId => {
                const op = players.find(x => x.id === opId);
                // Simple Match Win Pct calculation
                const rounds = op.wins + op.losses + op.draws;
                const winPct = rounds > 0 ? op.points / (rounds * 3) : 0;
                // MTG rule: minimum 0.33
                totalOpWinPct += Math.max(winPct, 0.33);
            });
            p.omw = (totalOpWinPct / p.opponents.length).toFixed(4);
        });

        // Sort: Points > OMW% > Random(stable)
        const sortedPlayers = [...players].sort((a, b) => {
            if (b.points !== a.points) return b.points - a.points;
            return b.omw - a.omw;
        });

        sortedPlayers.forEach((p, index) => {
            const tr = document.createElement('tr');
            tr.innerHTML = `
                <td>${index + 1}</td>
                <td style="text-align:left; font-weight:bold;">${p.name}</td>
                <td>${p.points}</td>
                <td>${(p.omw * 100).toFixed(2)}%</td>
                <td><span class="pod-label ${p.pod === 'A' ? 'pod-a' : 'pod-b'}">${p.pod}</span></td>
            `;
            tbody.appendChild(tr);
        });
    }
</script>

</body>
</html>
